======================== POWERSHELL ================================

most wmiobjects are Win32_ (means they only works on windows) which pulls information straight from the kernel about objects as opposed to just running the normal command to receive that information 

should not see pipes when viewing the processes

there are differences between user profiles in Powershell, Powershell ISE, and the newest version of powershell
start powershell -noprofile will load powershell without a profile
look for a powershell command ran with -windowstyle Hidden which means something is being hidden from you
can also change the version of the powershell you are about to run with -version <version number>

get-item WSMAN:\localhost\client\trustedhosts ping trusted hosts that can be Winrm'd into, can also use set item instead of give to set a trusted host make sure to add -concatenate to add as opposed to overwrite

invoke-command -comptername pwnd_host { restart-computer } -asjob 
invoke-command -computername a workstation,server C:\windows\findevil.ps1 
invoke-command is used to run commands remotely on other workstations with a small session while new-pssession which creates a more permanent session with the remote device

========================== WINDOWS REGISTRY ==============================

the registry is a heirarchial database that stores system wide settings as well as profile settings

hive keys always start with HKEY and are the main big groups of data like HKEY_Current_User or HKEY_Local_Machine
Registry keys are basically directories or subdirectories (subkeys) 
Registry values are the actual entries that contain data which can be read

HKEY_CLASSES_ROOT is a symbolic link to the classes subkey in in HKEY_Local_Machine which contains all the file extensions and what file pertains to them
ren can rename file extensions to change their extension to whatever you want ex calc.exe to calc.lol
classes have to have a default key with an actual value which defaults to string upon creation unless specified otherwise
the default key in classes describes what the files with said extension should be treated like ex an exefile which is executable which also needs a specific designation since there are many different executable types in windows

HKEY_Local_Machine is just the local machine settings

HKEY_CurrentUser is a symbolic link to the HKEY_Users key containing the settings for the currently logged in user

HKEY_Users has the normal settings for every user sorted by their sid and a classes key which specifies how you choose to open your extensions

only Admins can open and change any other HKEY then the one for their user account

HKEY_LOCAL_MACHINE KEYS
even administrators cant view the SAM key which holds security tokens and usernames for every user account
BCD00000000 deals with the boot configuration of the system
Hardware has drivers and other such hardware related data
Security contains the lsass configuration data
System has the boot or driver startup applications
Software has the system wide user downloaded applications 

the S-1-5-18 account is local system
the S-1-5-19 account is local service
the S-1-5-20 account is networking account

the 21 in a user account represents the domain while the numbers after represent the machine they are on and what order they were created in

Files are needed to store registry values to load them on every boot
user setting are stored in the NTUSER.DAT file for every user which is the user's registry settings
system settings are stored in the system32/config file which stores the registry settings where RegBack is the registry backup file

for the GUI regedit is used to manipulate the registry and add/delete keys or change data
data we use primarily is string, binary, and DWORD which can provide either a decimal or hexadecimal 32 bit value (QWORD for 64 bit)

subkeys can also be saved to export/import entire subkeys to other systems

to use the cmd to edit registry values use reg along with a command like ADD or DELETE 
reg query does not take astericks (and wildcards in general) which means you would have to take each individual sid using reg query

powershell uses get-item to just get KEYS and what their name is/data associated with them
get-childitem gives the subkeys for a key using -recurse to get all the subkeys as well as registry values and data ex get-childitem HKLM:\
set-itemproperty -path HKLM:\software\microsoft\windows\currentversion\run\etc.(any key/path) -name <name of registry value> -value <data to put in value>
new-itemproperty works the same as set-itemproperty but creates a new value

use get-psdrive gets the currently mounted filesystems then use new-PSdrive -name HKU -PSProvider registry -root HKEY_Users to mount the HKU as a PSDRIVE to view in powershell 
use add-content "<previous command>" $profile.allusersallhosts to add it to the users profiles then run &$profile.allusersallhosts to reload the file without restarting powershell
can alternatively just use registry::HKEY_Users instead of creating a new key to specify that its a registry path not a filesystem in PSDRIVE
on powershell can use wildcards like asterick* to query multiple values like all users ex get-item HKU:\*\<path>

HKLM\SOFTWARE\microsoft\windows\currentversion\profilelist contains a list of all users that have logged in
HKLM\SOFTWARE\microsoft\windows\currentversion\Image File Execution File Options tells a file what to do every single time it is executed
files can be created in Image File Execution to run other commands using the dataname Debugger then given it a executable path as data, though doing this requires real time monitoring to be disabled since this is a well known exploit
after performing this exploit you can go to the lock screen and click the ease of access button to open a command prompt as the system authority

use set-mppreference -DisableRealTimeMonitoring $True to disable windows defenders ability to prevent the previously described exploit

========================================== WINDOWS ADS (Alternate Data Stream) ===================================

windows uses NTFS (new technology file system) as its default which allows a lot more partitions (26 primary) and over a terrabyte of storage 
Windows used to use FAT (file allocation table) with only 4 partitions per hard drive followed by exFAT which still only held 16
NTFS added ADS to windows which allows data to be stealthily added to other data 
ADS can be used to create an invisible file that slowly fills up your hard drive without showing it on the GUI which eventually crashes the kernel
ADS works for antivirus and sequel servers
ADS must be viewed through the CLI since they dont show up in the GUI 
Create an ADS using for example echo "Elden Ring does deserve GOTY" > something.exe:truth.txt

to see ADS with powershell you have to get-item .\something.exe -stream * to check individual files followed by get-content .\calc.fuk -stream truth.txt to read it
you need a whole dang script to read through files in a directory to find ADS ex. 
get-childitem <path> | foreach-object { get-item $_.fullName -stream * } | where { $_.stream -ne $DATA } | get-content (to read it if ya need it) 

========================================== LINUX ==========================================

BASIC QUESTIONS TO ASK IMMEDIATELY
hostname and uname -a are used to find out where u are 
find out who you are using whoami and id command (gives user/group sid and username)
use sudo -l to see what you can and cant do on your machine
run w, who, ps -elf to find out who is on the system and whats going on
mark down anything interesting and figure out why its happening, how its happening, and what it is 
assuming this leads you to something human-readable, find out what's in there

FILESYSTEM HEIRARCHY

everything starts at Root /
/bin is for standard binary commands that dont require system access to run (can be /usr/bin, or /usr/local/bin depending on the machine)
/sbin is for system binaries that require system permissions to use (can be /usr/sbin depending on the machine)
/home is the default directory for any given user's home
/usr universal system resources, the catch all for all system files designed for us on the entire system on a given box
/etc everthing thats configurable, catch all for system level configuration files like shadow or passwd
/var files that are likely to change ex. logs
/boot all the files that are read during boot 
/dev all special device related files that reference specific devices like keyboards or mouses
/lib functions that are needed for given applications to run
/mnt used for permanently attatched external storage
/media removable media like usb's
/opt reserved for any files the user downloads themselves
/run runtime and variable data which holds information on the current session being run (mounted during boot) 
/tmp temporary files (everyone has access)
/proc processes (this is where ps -elf gets it's information to display)

USERS AND GROUPS (and permissions)

all users are held in /etc/passwd with their uid and guid
groups can be checked on the file /etc/groups in the format groupname:passwd placeholder:GID:who uses it as a supplementary group
ls -lisa shows the owner of and permissions for files (permissions formatted in UGO (user group other) with read write execute permissions) with the field after the permissions being the user and the group

SUID is a bit that will be in the user permission part of the permissions section signified with an s which allows anyone to execute as root (in passwd still only lets you change your data)
SGID lets you run with the permissions of the group specified (same as suid but groups)
STICKY BIT any file thats created with access via a group can only be deleted by the creator of said file

SCRIPTING
man --help provides options
man -k (keyword search) to find specific commands
apropos is also a keyword search
whereis locates commands through source and binary files (use -b for binary)

SHELLS 
echo $0 prints your shell if its cosix compliant
sh has no history file when writing commands
use cat /etc/shells to view all usable shells on the machine

FOR LATER
ifconfig is deprecated, now ip addr / ip a is used for interfaces and their ip addresses, mac addresses, statuses, etc.
netstat -ntlp shows ports and their status on the machine, you could also use ss -ntlp (could remove the n to get actual names of service ports) (l makes it only print listening ports)
can sudo for ports to see what processes are being used for said ports 
ip route, ip r, route shows what routes and interfaces are used to connect to particular networks
arp, ip neigh, ip n shows what the machine has comminicated with recently and whether it is still reachable or not
check firewalls using iptables -l to view the rules

================================= Windows Boot Process ================================

POST is what happens right after a windows device is turned on to check for hardware and confirm its existence

BIOS(older) which uses the MBR or UEFI(newer) which uses the GPT is the next step

BIOS loads the entire OS while UEFI (uses bootmgrfw.efi) is faster and has a secure boot which makes sure the current OS is the same as the initial OS on the system and makes sure no malware was downloaded since the last shutdown
UEFI is loaded into flash memory making it easier for updating and patching with 9 zettabytes of drive support
UEFI uses GPT (guid partition table) which checks for GPT in the current drive, if not found it asks the bootmgrfw.efi where GPT is in a UFI partition that goes straight to the boot manager that loads winload.efi or winresume.efi which loads the kernel on NtOSKRNL

BIOS looks for the MBR(first 512 bytes in the hard drive) which contains the code to start Bootmgr which manages the boot process and loads the boot configuration data store which keeps track of how the OS will load and what OS is installed on the machine
winload.exe(cold starts) which uses the BCD data which is bootconfiguration data or winresume.exe(sleeping/locking machine (warmstart)) load the Kernel (winresume.exe points to where the current data of machine state is stored in C:\ drive which saves how the computer was prior to locking it or not completly shutting it down)
Restarts turn off the entire OS and use winload as opposed to a fast start which uses winresume which means extra data has to be saved and loaded saving the machines previous state

after either UEFI or BIOS loads the kernel loads several files like paging the pagefile which stores less important information to be loaded at startup outside of RAM along with several other files owned by the kernel
the process manager is started by the kernel which starts the system idle process which displays the available resources left for CPU,Memory,Disk,etc. for your machine as a kernel process

NTOSKRNL starts a process called System which then loads smss.exe which loads sessions for login of up to multiple users
smss.exe makes a copy of itself for each user session starting with session 0 which is system and separate from other actual user sessions, this first session has SMSS run CSRSS.exe and WININIT.exe
WININIT runs LSASS.exe(user authentication (compare credentials with SAM)) and services.exe which launches SVCHOST.exe(the service that hosts services) which are used for initialization of windows
for actual user sessions(1 and up) SMSS runs CSRSS.exe and WINLOGON.exe
WINLOGON (which sends given credentials to a sub-process of LSASS proted to the given session) runs LOGONUI.exe(actual user interface) and USERINIT.exe(runs explorer upon authentication) which loads the Explorer.exe (kills userinit once its done) which is the GUI for the user and officially ends the boot process
0-1000 PIDS are process IDS reserved for system, meaning all session 0 processes are below 1000 and 3 user related sessions are created with system privileges in order to run correctly which are SMSS, CSSRS, and WINLOGON which are almost immediately closed once they are done executing
CSSRS allows windows to request services from other machines like servers to use for example DNS 

SAS is what forces you to press CTRL+ALT+DELETE to start authenticating

Type C:\Windows\Panther\setupact.log | findstr /i "Detected boot environment" can find whether the system booted with Bios or Uefi(using powershell)
or
bcdedit | findstr /i winload (or winresume) can find UEFI or BIOS mode and whether it was a warm or cold start
or 
msinfo32 which spawns a GUI that shows the BIOS mode (legacy is bios while UEFI is uefi)

\Device\HarddiskVolume1 is the true path of C:\ which can change

bcdedit allows the viewing and manipulation of BCD data

bcdedit prints the boot manager and some other basic information, the identifier being the most important field identifying what information is being displayed
device defines where in the system the identifier is being used
path shows what process was used 

bcdedit /set can change data values

bcdedit /set safeboot minimal makes the system boot in safemode at the most minimal level ex. just a command prompt and the bare minimum amount of data and services

bcdedit /set safeboot Network still gives a basic shell (cli powershell) but also loads network resources allowing for online use

bcdedit /set safebootalternateshell allows other shells besides cli or powershell like bash
bcdedit /deletevalue safeboot and /deletevalue safebootalternateshell will make the GUI run normally again
alternatively msconfig (can be typed in cli) can be brought up as a GUI then the boot settings can be changed to uncheck safeboot for the current OS
msconfig also lets you view services (both microsoft and not) and enable or disable them

hiberfile.sys is for hibernation file saving

=================================== LINUX Boot Process ========================================

Linux brings back BIOS and UEFI which again both use the MBR and GPT
- the boot loader is started by either BIOS or UEFI to find grub and start it

This time grub or grub.efi is started by the MBR or GPT to start the Linux kernel 
- grub finds the kernel image and starts it (config file is /boot/grub/menu.lst (old) actually look for /boot/grub/grub.cfg which contains the code for the GUI) and can be configured during boot via a GUI that appears, it can alter boot entreis, selecting different kernels, and modify initial ram disk

The kernel starts init which forks off either to SysV or SystemD (the kernel maintains the interaction between the user and the os)
- The Kernel initializes devices/drivers, mounts the filesystem, starts the program /sbin/init, and then init starts the rest of the system based off its runlevel
- The kernel has modules in order to run hardware devices which can be viewed using the lsmod command (the kernel itself is process 0 while it starts a daemon [kthreadd] with a pid of 2)

ls -l /sbin/init will show whether the system id systemD or SysV by whether there is a link to SystemD or not

Init is the service and process manager of all services/processes on the system
SysV - uses runlevels and can only start stop and pause said processes/services and runs everything in order handled by scripts being viewable via ls /etc/rc(0-6).d which specifies what scripts are run for each runlevel with /etc/init.d containing the actual scripts while the rc's contain links
SysV - default runlevel is 5 for multi-user network and GUI, runlevel 0 is halt, runlevel 1 is single-user, runlevel 2-5 are multi-user, and runlevel 6 is reboot which can be viewed using cat /etc/inittab
SysV - 2 = multiuser no networking, 3 = full multiuser with networking, 4 = full multiuser with networking and custom config, 5 full multiuser with with netowrking and GUI
SystemD - loads system in parallel from binaries to load the processes/services much faster than init with targets similar to runlevels in init
SystemD - SystemD can do a lot more than init like boot, login, move home directory, etc. ls -lisa /lib/systemd/system/default.target prints the default target which should be graphical.target for the gui
SystemD - uses targets like graphical.target as runlevels which can be viewed by using cat /lib/systemd/system/default.target to see what options it takes under the [Unit] header (requires = what target it needs while wants = what services can be ignored, conflicts = what services cant be running during initialization) 
SystemD - can have multiple folders for system processes like /etc/systemd/system, /lib/systemd/system, and /usr/lib/systemd/system which can all be ls -lisa'd

COMMANDS
lsblk shows what disks are in the system and where they are mounted
df -h shows where the disks are located and how much space they have 
(vda defines the disk while the number following it describes what partition of the disk it is talking about)
sudo xxd -l <bytes you want to read> -g 1 <specify what disk to read> this command allows you to read disks and view the information in them
(the MBR always starts with eb 63 90 with its HEX (specifies that the MBR eb=jump to memory position 63 in the current hex then executes, the 90 represents a command to ignore everything until the given jump ) the last 66 bytes (-2 for magic number (should be 55 aa)) are the partition's data
sudo parted -l can check where the bios is and check for bios or uefi which will show partition table msdos for bios and gpt for uefi
*THE MBR IS ALWAYS THE FIRST 512 BYTES OF YOUR VDA OR SDA DISK*
sudo dd if=/dev/sda(what disk to copy) of=MBRcopy(what to call it) bs=1(block size) count=512(number of bytes) this command copies a set amount of bytes of a disk to another file
dd creates an exact copy of the actual disk space copied and is literally the disk as a file (use file to prove it)
SystemD - uses systemctl to execute commands like systemctl list-dependecies graphical.target to see what processes your current target is running while also getting wants by everything before the first target in the service/process list
SystemD - systemctl show -p Wants graphical.target will also show all the wants of any given target
SystemD - systemctl list-unit-files will list all the unit files and their status where transient is temporary where units are the classifications/organization of services/processes being run by SystemD
SystemD - systemctl cat graphical.target will show the location and wants needs etc of a unit

/etc/profile(for logins, can be used for persistence and making any changes to all users login) is the profile for any given user while /etc/environment contains all the global variables and scripts cat /etc/profiles shows a script with all your options while cat /etc/environment show the paths to all the files it uses
/etc/profile (etc/profile is global but uses an individuals .profile) and your individual $HOME/.profile(or .bash_profile) file in your home directory are for interactive login shells
/etc/environment and $HOME/.bashrc are used for interactive non-login shells like starting up a terminal without logging in to a profile in said terminal
/etc/profile.d contains all the scripts /etc/profile runs

*Minas_Tirith is SysV while Terra is SystemD*



